/*
 * Code here is for RNR10
 */

//Attaches interupts to the encoders when storing the puleses, used for dead reckoning
void setupEncoderInterrupts(){
  attachInterrupt(Encoder_1.getIntNum(), isr_process_encoder1, RISING);
  attachInterrupt(Encoder_2.getIntNum(), isr_process_encoder2, RISING);
}

//Following two functions are used when reading the pulses generated by the encoders when the motors are moving
void isr_process_encoder1(void)
{
  if(digitalRead(Encoder_1.getPortB()) == 0){
    Encoder_1.pulsePosMinus();
  }
  else{
    Encoder_1.pulsePosPlus();
  }
}
void isr_process_encoder2(void)
{
  if(digitalRead(Encoder_2.getPortB()) == 0){
    Encoder_2.pulsePosMinus();
  }else{
    Encoder_2.pulsePosPlus();
  }
}


void printEncoderPulseValues(){
  Serial.println("Encoder 1: ");
  Serial.println(getEncoder1Pulses());
  Serial.println("Encoder 2: ");
  Serial.println(getEncoder2Pulses());
}

long getEncoder1Pulses(){
  return Encoder_1.getPulsePos();
}
long getEncoder2Pulses(){
  return Encoder_2.getPulsePos();
}


void setEncoder1Pulse(long pos){
  Encoder_1.setPulsePos(pos);
}
void setEncoder2Pulse(long pos){
  Encoder_2.setPulsePos(pos);
}


void resetEncoderValues(){
  Encoder_1.setPulsePos(0);
  Encoder_2.setPulsePos(0);
  resetGyroStartAndEnd();
}

//When calculating distance travelled, it is better to calculate the average between the encoders to lower the error margin
float getEncoderAverage(){
  return (((-1* getEncoder1Pulses()) + getEncoder2Pulses() ) * 0.5); //*-1 since the first motor is inverted physically.
}
